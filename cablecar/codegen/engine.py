"""Jinja2-based code generation engine for reproducible analysis scripts."""
from __future__ import annotations
from pathlib import Path
from typing import Any
import jinja2
from cablecar.codegen.provenance import AnalysisProvenance

class CodeGenerator:
    """Generate reproducible Python and R analysis scripts from templates."""

    def __init__(self, template_dir: str | Path | None = None):
        if template_dir is None:
            template_dir = Path(__file__).parent / "templates"
        self._template_dir = Path(template_dir)
        self._env = jinja2.Environment(
            loader=jinja2.FileSystemLoader([
                str(self._template_dir / "python"),
                str(self._template_dir / "r"),
                str(self._template_dir),
            ]),
            trim_blocks=True,
            lstrip_blocks=True,
            keep_trailing_newline=True,
        )

    def generate(
        self,
        language: str,
        analysis_type: str,
        provenance: AnalysisProvenance,
        **kwargs,
    ) -> str:
        """Generate analysis code from a template.

        Args:
            language: "python" or "r"
            analysis_type: "cohort", "table1", "regression", "survival", "prediction"
            provenance: Analysis provenance chain
            **kwargs: Additional template variables
        """
        template_name = f"{analysis_type}.{'py' if language == 'python' else 'R'}.j2"

        try:
            template = self._env.get_template(template_name)
        except jinja2.TemplateNotFound:
            # Fall back to generating code programmatically
            return self._generate_fallback(language, analysis_type, provenance, **kwargs)

        context = {
            "provenance": provenance,
            "study_name": provenance.study_name,
            "data_source": provenance.data_source,
            "schema_name": provenance.schema_name,
            "cohort": provenance.cohort_definition,
            "steps": provenance.steps,
            **kwargs,
        }

        return template.render(**context)

    def _generate_fallback(
        self,
        language: str,
        analysis_type: str,
        provenance: AnalysisProvenance,
        **kwargs,
    ) -> str:
        """Generate code without a template using programmatic construction."""
        if language == "python":
            return self._generate_python(analysis_type, provenance, **kwargs)
        elif language == "r":
            return self._generate_r(analysis_type, provenance, **kwargs)
        else:
            raise ValueError(f"Unsupported language: {language}")

    def _generate_python(self, analysis_type: str, prov: AnalysisProvenance, **kwargs) -> str:
        lines = [
            '"""',
            f'Reproducible Analysis: {prov.study_name}',
            f'Generated by CableCar v2',
            f'Data source: {prov.data_source}',
            '"""',
            '',
            'import pandas as pd',
            'import numpy as np',
            'from pathlib import Path',
            '',
            '# --- Configuration ---',
            f'DATA_DIR = Path("{prov.data_source}")',
            '',
            '# --- Load Data ---',
        ]

        # Add data loading
        if prov.schema_name == "clif":
            tables = ["patient", "hospitalization", "adt", "vitals", "labs",
                      "respiratory_support", "medication_admin_continuous", "patient_assessments"]
            for table in tables:
                lines.append(f'{table} = pd.read_csv(DATA_DIR / "{table}.csv")')
            lines.append('')

        # Add cohort definition
        if prov.cohort_definition:
            lines.append('# --- Define Cohort ---')
            lines.append(f'cohort = hospitalization.copy()')
            for criterion in prov.cohort_definition.get("inclusion", []):
                col = criterion.get("column", "")
                op = criterion.get("op", "==")
                val = criterion.get("value", "")
                if isinstance(val, str):
                    lines.append(f'cohort = cohort[cohort["{col}"] {op} "{val}"]')
                else:
                    lines.append(f'cohort = cohort[cohort["{col}"] {op} {val}]')
            lines.append(f'print(f"Cohort size: {{len(cohort)}}")')
            lines.append('')

        # Add analysis-specific code
        if analysis_type == "table1":
            lines.extend(self._python_table1(kwargs))
        elif analysis_type == "regression":
            lines.extend(self._python_regression(kwargs))
        elif analysis_type == "survival":
            lines.extend(self._python_survival(kwargs))

        return '\n'.join(lines) + '\n'

    def _generate_r(self, analysis_type: str, prov: AnalysisProvenance, **kwargs) -> str:
        lines = [
            '# -------------------------------------------',
            f'# Reproducible Analysis: {prov.study_name}',
            f'# Generated by CableCar v2',
            f'# Data source: {prov.data_source}',
            '# -------------------------------------------',
            '',
            'library(tidyverse)',
            'library(broom)',
            '',
            '# --- Configuration ---',
            f'data_dir <- "{prov.data_source}"',
            '',
            '# --- Load Data ---',
        ]

        if prov.schema_name == "clif":
            tables = ["patient", "hospitalization", "adt", "vitals", "labs",
                      "respiratory_support", "medication_admin_continuous", "patient_assessments"]
            for table in tables:
                lines.append(f'{table} <- read_csv(file.path(data_dir, "{table}.csv"))')
            lines.append('')

        # Add cohort definition
        if prov.cohort_definition:
            lines.append('# --- Define Cohort ---')
            lines.append('cohort <- hospitalization')
            for criterion in prov.cohort_definition.get("inclusion", []):
                col = criterion.get("column", "")
                op = criterion.get("op", "==")
                val = criterion.get("value", "")
                if isinstance(val, str):
                    lines.append(f'cohort <- cohort %>% filter({col} {op} "{val}")')
                else:
                    lines.append(f'cohort <- cohort %>% filter({col} {op} {val})')
            lines.append('cat(sprintf("Cohort size: %d\\n", nrow(cohort)))')
            lines.append('')

        if analysis_type == "table1":
            lines.extend(self._r_table1(kwargs))
        elif analysis_type == "regression":
            lines.extend(self._r_regression(kwargs))
        elif analysis_type == "survival":
            lines.extend(self._r_survival(kwargs))

        return '\n'.join(lines) + '\n'

    def _python_table1(self, kwargs) -> list[str]:
        variables = kwargs.get("variables", [])
        stratify = kwargs.get("stratify_by", "")
        lines = ['# --- Table 1: Baseline Characteristics ---', 'from scipy import stats', '']
        if stratify:
            lines.append(f'groups = cohort.groupby("{stratify}")')
            lines.append('for name, group in groups:')
            lines.append(f'    print(f"\\nGroup: {{name}} (n={{len(group)}})")')
            for var in variables:
                lines.append(f'    print(f"  {var}: {{group[\"{var}\"].describe()}}")')
        else:
            for var in variables:
                lines.append(f'print("{var}:")')
                lines.append(f'print(cohort["{var}"].describe())')
                lines.append('')
        return lines

    def _python_regression(self, kwargs) -> list[str]:
        outcome = kwargs.get("outcome", "outcome")
        predictors = kwargs.get("predictors", [])
        model_type = kwargs.get("model_type", "logistic")
        lines = ['# --- Regression Analysis ---']
        if model_type == "logistic":
            lines.extend([
                'import statsmodels.api as sm',
                '',
                f'y = cohort["{outcome}"]',
                f'X = cohort[{predictors}]',
                'X = pd.get_dummies(X, drop_first=True, dtype=float)',
                'X = sm.add_constant(X)',
                '',
                'model = sm.Logit(y, X).fit(disp=0)',
                'print(model.summary2())',
                '',
                '# Odds ratios with CIs',
                'odds_ratios = np.exp(model.params)',
                'ci = np.exp(model.conf_int())',
                'results = pd.DataFrame({',
                '    "OR": odds_ratios,',
                '    "CI_lower": ci[0],',
                '    "CI_upper": ci[1],',
                '    "p_value": model.pvalues,',
                '})',
                'print("\\nOdds Ratios:")',
                'print(results)',
            ])
        elif model_type == "linear":
            lines.extend([
                'import statsmodels.api as sm',
                '',
                f'y = cohort["{outcome}"]',
                f'X = cohort[{predictors}]',
                'X = pd.get_dummies(X, drop_first=True, dtype=float)',
                'X = sm.add_constant(X)',
                '',
                'model = sm.OLS(y, X).fit()',
                'print(model.summary())',
            ])
        return lines

    def _python_survival(self, kwargs) -> list[str]:
        time_col = kwargs.get("time_col", "time")
        event_col = kwargs.get("event_col", "event")
        group_col = kwargs.get("group_col", "")
        lines = [
            '# --- Survival Analysis ---',
            'from lifelines import KaplanMeierFitter, CoxPHFitter',
            'from lifelines.statistics import logrank_test',
            '',
            'kmf = KaplanMeierFitter()',
        ]
        if group_col:
            lines.extend([
                f'for name, group in cohort.groupby("{group_col}"):',
                f'    kmf.fit(group["{time_col}"], group["{event_col}"], label=str(name))',
                '    print(f"Group {name}: Median survival = {kmf.median_survival_time_}")',
                '',
                '# Log-rank test',
                f'groups = cohort["{group_col}"].unique()',
                f'result = logrank_test(',
                f'    cohort[cohort["{group_col}"] == groups[0]]["{time_col}"],',
                f'    cohort[cohort["{group_col}"] == groups[1]]["{time_col}"],',
                f'    cohort[cohort["{group_col}"] == groups[0]]["{event_col}"],',
                f'    cohort[cohort["{group_col}"] == groups[1]]["{event_col}"],',
                ')',
                'print(f"Log-rank test p-value: {result.p_value:.4f}")',
            ])
        else:
            lines.extend([
                f'kmf.fit(cohort["{time_col}"], cohort["{event_col}"])',
                'print(f"Median survival: {kmf.median_survival_time_}")',
            ])
        return lines

    def _r_table1(self, kwargs) -> list[str]:
        variables = kwargs.get("variables", [])
        stratify = kwargs.get("stratify_by", "")
        var_str = ", ".join(f'"{v}"' for v in variables)
        lines = ['# --- Table 1: Baseline Characteristics ---', '']
        if stratify:
            lines.extend([
                f'table1_vars <- c({var_str})',
                f'cohort %>%',
                f'  group_by({stratify}) %>%',
                f'  summarise(across(all_of(table1_vars), ',
                f'    list(mean = ~mean(., na.rm = TRUE),',
                f'         sd = ~sd(., na.rm = TRUE),',
                f'         median = ~median(., na.rm = TRUE)),',
                f'    .names = "{{.col}}_{{.fn}}"))',
            ])
        else:
            lines.extend([
                f'table1_vars <- c({var_str})',
                'cohort %>%',
                '  summarise(across(all_of(table1_vars),',
                '    list(mean = ~mean(., na.rm = TRUE),',
                '         sd = ~sd(., na.rm = TRUE),',
                '         median = ~median(., na.rm = TRUE)),',
                '    .names = "{.col}_{.fn}"))',
            ])
        return lines

    def _r_regression(self, kwargs) -> list[str]:
        outcome = kwargs.get("outcome", "outcome")
        predictors = kwargs.get("predictors", [])
        model_type = kwargs.get("model_type", "logistic")
        pred_str = " + ".join(predictors)
        lines = ['# --- Regression Analysis ---', '']
        if model_type == "logistic":
            lines.extend([
                f'model <- glm({outcome} ~ {pred_str},',
                '             data = cohort, family = binomial())',
                '',
                '# Summary',
                'tidy(model, conf.int = TRUE, exponentiate = TRUE) %>%',
                '  select(term, estimate, conf.low, conf.high, p.value) %>%',
                '  rename(OR = estimate, CI_lower = conf.low, CI_upper = conf.high)',
                '',
                '# Model fit',
                'glance(model)',
            ])
        elif model_type == "linear":
            lines.extend([
                f'model <- lm({outcome} ~ {pred_str}, data = cohort)',
                '',
                'tidy(model, conf.int = TRUE) %>%',
                '  select(term, estimate, conf.low, conf.high, p.value)',
                '',
                'glance(model)',
            ])
        return lines

    def _r_survival(self, kwargs) -> list[str]:
        time_col = kwargs.get("time_col", "time")
        event_col = kwargs.get("event_col", "event")
        group_col = kwargs.get("group_col", "")
        lines = [
            '# --- Survival Analysis ---',
            'library(survival)',
            'library(survminer)',
            '',
        ]
        if group_col:
            lines.extend([
                f'surv_obj <- Surv({time_col}, {event_col}) ~ {group_col}',
                'fit <- survfit(surv_obj, data = cohort)',
                'ggsurvplot(fit, data = cohort, pval = TRUE, risk.table = TRUE)',
                '',
                '# Log-rank test',
                'survdiff(surv_obj, data = cohort)',
            ])
        else:
            lines.extend([
                f'surv_obj <- Surv({time_col}, {event_col}) ~ 1',
                'fit <- survfit(surv_obj, data = cohort)',
                'ggsurvplot(fit, data = cohort)',
            ])
        return lines

    def list_templates(self) -> list[str]:
        """List available templates."""
        templates = []
        for lang_dir in ["python", "r"]:
            lang_path = self._template_dir / lang_dir
            if lang_path.exists():
                templates.extend(str(f.relative_to(self._template_dir)) for f in lang_path.glob("*.j2"))
        return templates
